---
sidebar_position: 3
---

# Таймер тренировки

Компонент `Timer` предоставляет надежный таймер для отслеживания времени тренировки, который работает даже когда PWA приложение свернуто на мобильных устройствах.

## Возможности

- Точное отслеживание времени даже при сворачивании приложения
- Сохранение состояния и времени между сессиями
- Автоматическое восстановление после перезагрузки приложения
- Интеграция с PWA-приложениями
- Поддержка паузы/возобновления
- Предотвращение утечек памяти
- Автоматический перезапуск при добавлении подходов (настраивается)
- Глобальное состояние для связи между компонентами
- Автоматический запуск при первом подходе

## API

Компонент `Timer` не принимает пропсы и работает автономно через глобальное состояние.

### Хук useWorkoutTimer

```typescript
interface UseWorkoutTimerReturn {
  time: number
  isRunning: boolean
  isPaused: boolean
  startTimer: () => void
  pauseTimer: () => void
  resetTimer: () => void
  togglePause: () => void
  handleSetAdded: () => void
}
```

### Глобальное состояние таймера

```typescript
interface TimerState {
  onSetAdded: (() => void) | null
  setOnSetAdded: (callback: (() => void) | null) => void
  triggerSetAdded: () => void
}
```

## Пример использования

```tsx
import { Timer } from "@/widgets/Timer";

export function WorkoutTimerExample() {
  return <Timer />;
}
```

### Интеграция с добавлением подходов

```tsx
import { useTimerStore } from "@/widgets/Timer";

export function AddSetComponent() {
  const { triggerSetAdded } = useTimerStore();

  const handleAddSet = () => {
    // Логика добавления подхода
    triggerSetAdded(); // Уведомляем таймер о добавлении подхода
  };

  return <button onClick={handleAddSet}>Добавить подход</button>;
}
```

## Принцип работы

Таймер основан на использовании абсолютных временных меток, что позволяет корректно вычислять прошедшее время даже когда приложение свернуто.

### Ключевые особенности реализации:

1. **Глобальное состояние**: Использует Zustand для управления событиями добавления подходов
2. **Сохранение в LocalStorage**: Время начала и прошедшее время сохраняются локально
3. **Временные метки**: Расчет времени основан на абсолютных временных метках
4. **Интервальное обновление**: UI обновляется каждую секунду через `setInterval`
5. **События жизненного цикла**: Обработка `visibilitychange`, `focus`, `pageshow`
6. **Интеграция с настройками**: Автоматическое чтение настройки `shouldRestartOnNewSet`

### Обработка сворачивания приложения

Когда приложение сворачивается, таймер сохраняет текущее время и временную метку начала. При возвращении в приложение таймер вычисляет прошедшее время, добавляет его к сохраненному значению и обновляет временную метку начала.

### Логика перезапуска при добавлении подходов

1. **Если настройка включена** (`shouldRestartOnNewSet: true`):
   - Таймер сбрасывается на 0
   - Автоматически запускается заново
   
2. **Если настройка выключена**:
   - Таймер запускается автоматически при первом подходе (если не был запущен)
   - Продолжает работать без перезапуска при последующих подходах

## Архитектура

### Компоненты системы:

1. **Timer.tsx** - UI компонент с кнопками управления
2. **useWorkoutTimer.ts** - Хук с логикой таймера
3. **timer.store.ts** - Глобальное состояние для событий
4. **Интеграция с настройками** - Автоматическое чтение `shouldRestartOnNewSet`

## Предотвращение утечек памяти

Таймер спроектирован с учетом предотвращения утечек памяти:

1. **Очистка интервалов**: Все `setInterval` очищаются в cleanup функциях
2. **Удаление обработчиков**: Все event listeners корректно удаляются
3. **useRef для интервалов**: Избегание проблем с замыканиями
4. **Безопасный localStorage**: Операции обернуты в try-catch
5. **Проверка монтирования**: Предотвращение обновлений в размонтированных компонентах
6. **Принудительный перезапуск**: При перезапуске таймера состояние сбрасывается через `setTimeout`

## Интеграция с PWA

Таймер специально оптимизирован для работы в PWA-приложениях на мобильных устройствах:

1. Использует localStorage для сохранения состояния
2. Обрабатывает события жизненного цикла PWA
3. Корректно восстанавливается после сворачивания приложения
4. Работает в различных режимах энергосбережения

## Устранение неполадок

Если таймер не считает время или работает некорректно:

1. **Нет доступа к localStorage**: Убедитесь, что приложение имеет доступ к localStorage
2. **Серверный рендеринг**: Проверьте наличие директивы `'use client'`
3. **Проблемы с форматированием**: Убедитесь в корректности функции `formatTime`
4. **Утечки памяти**: Проверьте корректное размонтирование компонентов
5. **Таймер ломается при добавлении подходов**: Убедитесь, что `triggerSetAdded()` вызывается после успешного добавления подхода
6. **Настройки не применяются**: Проверьте, что `useSettingsStore` возвращает актуальное значение `shouldRestartOnNewSet`